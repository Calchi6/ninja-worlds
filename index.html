<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no"/>
<title>Ninja Worlds ‚Äî Playable Base</title>
<style>
  :root{--ink:#fff;--panel:rgba(30,18,18,.92);--chip:rgba(0,0,0,.55)}
  html,body{margin:0;height:100%;background:#1a0f0f;color:var(--ink);font:14px/1.2 system-ui,-apple-system,Segoe UI,Inter}
  #game{display:block;width:100vw;height:100vh;touch-action:none;background:#1a0f0f}

  /* HUD */
  #hud{position:fixed;left:12px;top:10px;display:flex;gap:10px;z-index:5}
  .badge{background:var(--chip);padding:6px 10px;border-radius:10px;font-weight:800}

  /* Start / Pause / Win overlays */
  .overlay{position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.42);backdrop-filter:blur(8px);z-index:10}
  .panel{background:var(--panel);border:1px solid rgba(255,255,255,.15);padding:18px 22px;border-radius:14px;min-width:280px;text-align:center}
  .panel h1{margin:.25em 0 10px;font:800 22px/1.2 system-ui}
  .btn{border:0;border-radius:10px;padding:10px 16px;font-weight:800;background:#fff;color:#000;cursor:pointer}
  .hide{display:none}

  /* Touch controls */
  #touch{position:fixed;left:12px;right:12px;bottom:12px;display:none;justify-content:space-between;align-items:flex-end;gap:12px;z-index:6;pointer-events:none}
  .pad{display:flex;gap:12px;pointer-events:auto}
  .tbtn{width:72px;height:72px;border-radius:999px;border:0;background:rgba(255,255,255,.12);box-shadow:inset 0 0 0 2px rgba(255,255,255,.18);color:#fff;font:800 14px system-ui;display:grid;place-items:center}
  .tbtn:active{transform:scale(.97)}
  @media (max-width:820px){ #touch{display:flex} }
</style>
</head>
<body>
<canvas id="game"></canvas>

<!-- HUD -->
<div id="hud" class="hide">
  <div id="hp" class="badge">HP: ‚ù§‚ù§‚ù§</div>
  <div id="coins" class="badge">Coins: 0</div>
  <div class="badge">Pause: P/Esc</div>
</div>

<!-- Touch Controls -->
<div id="touch">
  <div class="pad">
    <button id="tLeft"  class="tbtn">‚óÄÔ∏é</button>
    <button id="tRight" class="tbtn">‚ñ∂Ô∏é</button>
  </div>
  <div class="pad">
    <button id="tJump"  class="tbtn">‚§¥Ô∏é</button>
  </div>
</div>

<!-- Start -->
<div id="title" class="overlay">
  <div class="panel">
    <h1>Ninja Worlds ‚Äî Playable Base</h1>
    <p style="opacity:.9;margin:0 0 12px">Move: A/D or Arrows ¬∑ Jump: Space ¬∑ Pause: P/Esc</p>
    <button id="playBtn" class="btn">Play</button>
  </div>
</div>

<!-- Pause -->
<div id="pause" class="overlay hide">
  <div class="panel">
    <h1>Paused</h1>
    <div style="display:flex;gap:10px;justify-content:center">
      <button id="resumeBtn" class="btn">Resume</button>
      <button id="restartBtn" class="btn">Restart</button>
    </div>
  </div>
</div>

<!-- Win -->
<div id="win" class="overlay hide">
  <div class="panel">
    <h1>You Win! üéâ</h1>
    <div style="display:flex;gap:10px;justify-content:center">
      <button id="againBtn" class="btn">Play Again</button>
    </div>
  </div>
</div>

<script>
/* ===== Canvas (CSS pixel coordinates) ===== */
const C = document.getElementById('game'), g = C.getContext('2d');
function resize(){
  const dpr = devicePixelRatio||1;
  C.width  = Math.round(innerWidth  * dpr);
  C.height = Math.round(innerHeight * dpr);
  C.style.width  = innerWidth +'px';
  C.style.height = innerHeight+'px';
  g.setTransform(dpr,0,0,dpr,0,0);
}
resize(); addEventListener('resize', resize);

/* ===== Utils ===== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const AABB=(a,b)=>a.x<b.x+b.w&&a.x+a.w>b.x&&a.y<b.y+b.h&&a.y+a.h>b.y;
function beep(f=660,d=.05){
  try{
    const AC=window.AudioContext||window.webkitAudioContext; if(!AC) return;
    if(!window._ac) window._ac=new AC();
    const ac=window._ac,o=ac.createOscillator(),v=ac.createGain();
    o.type='square'; o.frequency.value=f; v.gain.value=.04; o.connect(v); v.connect(ac.destination);
    o.start(); o.stop(ac.currentTime+d);
  }catch(_){}
}

/* ===== Level Data ===== */
const TILE=32;
const Level={w:160,h:20,map:[]};
function makeLevel(){
  Level.map.length=0;
  for(let y=0;y<Level.h;y++){
    const row=new Array(Level.w).fill(0);
    if(y>=Level.h-3) row.fill(1); // ground band (solid:1)
    Level.map.push(row);
  }
  // pits in ground band
  for(const x of [18,19,20, 54,55, 92,93, 120]) Level.map[Level.h-3][x]=0;

  // bricks (platforms:2)
  const plat=(tx,ty,len)=>{for(let i=0;i<len;i++) if(Level.map[ty]) Level.map[ty][tx+i]=2;};
  plat(10, Level.h-6, 6);
  plat(28, Level.h-8, 6);
  plat(46, Level.h-10,6);
  plat(64, Level.h-7, 8);
  plat(82, Level.h-9, 7);
  plat(104,Level.h-11,7);

  // coins (3)
  const coin=(tx,ty)=>{if(Level.map[ty]) Level.map[ty][tx]=3;};
  [12,30,48,66,84,106].forEach((x,i)=>coin(x, Level.h-7-i));

  // spikes (4)
  Level.map[Level.h-4][60]=4; Level.map[Level.h-4][61]=4; Level.map[Level.h-4][62]=4;

  // spring (7)
  Level.map[Level.h-4][37]=7;

  // moving platform spawn space (we draw actual mover separately)

  // flag (win:5)
  Level.map[Level.h-4][Level.w-6]=5;
}
makeLevel();

const isSolid = id => id===1||id===2;
const isDeadly= id => id===4;

/* robust tile lookup (CSS px) */
function tileAt(px,py){
  const tx=Math.floor(px/TILE), ty=Math.floor(py/TILE);
  if(ty<0||ty>=Level.h||tx<0||tx>=Level.w) return 0;
  return Level.map[ty][tx]|0;
}

/* ===== Entities ===== */
const player={
  x:3*TILE, y:(Level.h-4)*TILE-28, w:22,h:28,
  vx:0,vy:0, face:1,
  on:false, jumps:0,
  hp:3, coins:0
};
const cam={x:0,y:0};
const HUD={hp:document.getElementById('hp'), coins:document.getElementById('coins')};

function updateHUD(){
  HUD.hp.textContent='HP: '+ '‚ù§'.repeat(player.hp)+'‚ô°'.repeat(Math.max(0,3-player.hp));
  HUD.coins.textContent='Coins: '+player.coins;
}
function damage(n){
  player.hp=Math.max(0,player.hp-n); updateHUD(); if(player.hp===0) respawn();
}
function respawn(){
  player.x=3*TILE; player.y=(Level.h-4)*TILE - player.h;
  player.vx=player.vy=0; player.on=false; coyTime=0; jumpBuf=0;
}

/* Enemies: simple walkers you can stomp */
const enemies=[];
function addWalker(tx,ty,dir=1){ enemies.push({x:tx*TILE+6,y:ty*TILE-26,w:20,h:26,vx:60*dir,vy:0,alive:true}); }
for(let i=14;i<Level.w-10;i+=16) addWalker(i, Level.h-3);

/* Moving platform (simple horizontal) */
const movers=[
  {x:48*TILE, y:(Level.h-7)*TILE, w:64, h:12, speed:70, a:48*TILE, b:56*TILE, dir:1}
];

/* ===== Physics (Mario-ish) ===== */
const PHY={
  RUN_MAX: 360,  ACC_G: 900,  DEC_G: 1400,  ACC_A: 650,
  GRAV_UP: 1100, GRAV_DOWN: 1800, TERM_V: 1600,
  JUMP_V: 760,   CUT_V: 280,
  COYOTE:.08,    JBUF:.12
};
let coyTime=0, jumpBuf=0, prevJump=false;

/* ===== Input (keyboard + touch) ===== */
const keys=Object.create(null);
addEventListener('keydown',e=>{
  const k=e.key.toLowerCase();
  if([' ','arrowleft','arrowright','arrowup','arrowdown'].includes(e.key)) e.preventDefault();
  keys[k]=true;
  if(k==='p' || e.key==='Escape'){ if(running) showPause(true); else if(!UI.pause.classList.contains('hide')) showPause(false); }
});
addEventListener('keyup',e=>{ keys[e.key.toLowerCase()]=false; });
addEventListener('blur',()=>{ for(const k in keys) keys[k]=false; });

function bindHold(el, down, up){
  const press=e=>{ e.preventDefault(); down(); };
  const lift =e=>{ e.preventDefault(); up(); };
  el.addEventListener('pointerdown',press);
  el.addEventListener('pointerup',lift);
  el.addEventListener('pointercancel',lift);
  el.addEventListener('pointerleave',lift);
}
bindHold(document.getElementById('tLeft'),
  ()=>{ keys.a=keys.arrowleft=true; },
  ()=>{ keys.a=keys.arrowleft=false; }
);
bindHold(document.getElementById('tRight'),
  ()=>{ keys.d=keys.arrowright=true; },
  ()=>{ keys.d=keys.arrowright=false; }
);
bindHold(document.getElementById('tJump'),
  ()=>{ keys[' ']=keys.space=true; },
  ()=>{ keys[' ']=keys.space=false; }
);

/* ===== Collisions (separate axis + hazards/coins/flag) ===== */
function resolveX(ent, dx){
  if(dx===0) return;
  ent.x += dx;
  const L=Math.floor(ent.x/TILE), R=Math.floor((ent.x+ent.w-1)/TILE);
  const T=Math.floor(ent.y/TILE), B=Math.floor((ent.y+ent.h-1)/TILE);
  for(let ty=T; ty<=B; ty++){
    for(let tx=L; tx<=R; tx++){
      const id=tileAt(tx*TILE+1, ty*TILE+1);
      if(!isSolid(id)) continue;
      if(dx>0) ent.x = tx*TILE - ent.w; else ent.x = (tx+1)*TILE;
      ent.vx=0; return;
    }
  }
  if(ent===player){
    for(let ty=T; ty<=B; ty++) for(let tx=L; tx<=R; tx++){
      const id=tileAt(tx*TILE+1, ty*TILE+1);
      if(id===3){ Level.map[ty][tx]=0; player.coins++; updateHUD(); beep(880,.05); }
      if(id===4) damage(1);
      if(id===5) win();
    }
  }
}
function resolveY(ent, dy){
  if(dy===0) return;
  ent.y += dy;
  const L=Math.floor(ent.x/TILE), R=Math.floor((ent.x+ent.w-1)/TILE);
  const T=Math.floor(ent.y/TILE), B=Math.floor((ent.y+ent.h-1)/TILE);
  let landed=false;
  for(let ty=T; ty<=B; ty++){
    for(let tx=L; tx<=R; tx++){
      const id=tileAt(tx*TILE+1, ty*TILE+1);
      if(!isSolid(id)) continue;
      if(dy>0){ ent.y = ty*TILE - ent.h; ent.vy=0; landed=true; }
      else    { ent.y = (ty+1)*TILE; if(ent.vy<0) ent.vy=0; }
      ty=B+1; break;
    }
  }
  if(ent===player){
    player.on = landed;
    for(let ty=T; ty<=B; ty++){
      for(let tx=L; tx<=R; tx++){
        const id=tileAt(tx*TILE+1, ty*TILE+1);
        if(id===3){ Level.map[ty][tx]=0; player.coins++; updateHUD(); beep(880,.05); }
        if(id===4) damage(1);
        if(id===5) win();
        if(id===7 && dy>0){ player.vy = -PHY.JUMP_V*1.25; beep(760,.06); } // spring
      }
    }
  }
}

/* ===== Game flow ===== */
const UI={
  title:document.getElementById('title'),
  hud:document.getElementById('hud'),
  pause:document.getElementById('pause'),
  win:document.getElementById('win')
};
document.getElementById('playBtn').addEventListener('pointerdown', startGame, {once:true});
UI.title.addEventListener('pointerdown', (e)=>{ if(e.target===UI.title) startGame(); }, {once:true});
addEventListener('keydown', e=>{ if(!running) startGame(); }, {once:true});
document.getElementById('resumeBtn').onclick=()=>showPause(false);
document.getElementById('restartBtn').onclick=()=>{ showPause(false); restart(); };
document.getElementById('againBtn').onclick=()=>{ UI.win.classList.add('hide'); restart(); };

function startGame(){
  try{
    const AC=window.AudioContext||window.webkitAudioContext;
    if(AC){ if(!window._ac) window._ac=new AC(); if(window._ac.state==='suspended') window._ac.resume(); }
  }catch(_){}
  UI.title.classList.add('hide');
  UI.hud.classList.remove('hide');
  updateHUD();
  running=true;
}
function showPause(on){
  if(on){ running=false; UI.pause.classList.remove('hide'); }
  else { UI.pause.classList.add('hide'); running=true; }
}
function win(){
  running=false; UI.win.classList.remove('hide');
}
function restart(){
  player.x=3*TILE; player.y=(Level.h-4)*TILE - player.h;
  player.vx=player.vy=0; player.hp=3; player.coins=0; updateHUD();
  enemies.forEach(e=>{ e.alive=true; e.x=Math.round(e.x); e.y=Math.round(e.y); });
  UI.hud.classList.remove('hide');
  running=true;
}

/* ===== Loop ===== */
let running=false, paused=false, last=performance.now();
function update(dt){
  if(!running) return;

  // input
  const left=!!(keys.a||keys.arrowleft);
  const right=!!(keys.d||keys.arrowright);
  const jump=!!(keys[' ']||keys.space);

  if(right) player.face=1; else if(left) player.face=-1;

  // coyote & jump buffer
  coyTime = player.on ? PHY.COYOTE : Math.max(0, coyTime - dt);
  if(jump) jumpBuf = PHY.JBUF; else jumpBuf = Math.max(0, jumpBuf - dt);

  // horizontal
  const want=(right?1:0)-(left?1:0);
  if(want!==0){
    const acc=player.on? PHY.ACC_G : PHY.ACC_A;
    player.vx += want*acc*dt;
    player.vx = clamp(player.vx, -PHY.RUN_MAX, PHY.RUN_MAX);
  }else if(player.on){
    const m=Math.min(Math.abs(player.vx), PHY.DEC_G*dt);
    player.vx -= Math.sign(player.vx)*m; if(Math.abs(player.vx)<0.01) player.vx=0;
  }

  // jump
  const canGroundJump = (coyTime>0);
  if(jumpBuf>0 && canGroundJump){
    player.vy=-PHY.JUMP_V; player.on=false; coyTime=0; jumpBuf=0; player.jumps=1; beep(600,.05);
  }
  // short-hop
  if(!jump && prevJump && player.vy < -PHY.CUT_V) player.vy = -PHY.CUT_V;
  prevJump = jump;

  // gravity
  const grav = (player.vy<0)? PHY.GRAV_UP : PHY.GRAV_DOWN;
  player.vy = Math.min(PHY.TERM_V, player.vy + grav*dt);

  // integrate vs tiles
  resolveX(player, player.vx*dt);
  const py=player.y;
  resolveY(player, player.vy*dt);
  if(player.on && player.y===py) player.jumps=0;

  // move platform
  for(const p of movers){
    p.x += p.speed * p.dir * dt;
    if(p.x < p.a){ p.x=p.a; p.dir=1; }
    if(p.x > p.b){ p.x=p.b; p.dir=-1; }
    // ride the player if on top
    const onTop = AABB(player,{x:p.x,y:p.y,w:p.w,h:p.h}) &&
                  (player.y + player.h) <= p.y + 6 && player.vy>=0;
    if(onTop){ player.y = p.y - player.h; player.vy=0; player.on=true; player.x += p.speed * p.dir * dt; }
  }

  // enemies
  for(const e of enemies){
    if(!e.alive) continue;
    const aheadX = e.x + (e.vx>0? e.w+1 : -1);
    const footY  = e.y + e.h + 2;
    const wall   = tileAt(aheadX, e.y + e.h/2);
    const ground = tileAt(e.x + e.w/2 + (e.vx>0?14:-14), footY);
    if(isSolid(wall) || !isSolid(ground)) e.vx *= -1;

    e.vy = Math.min(PHY.TERM_V, e.vy + PHY.GRAV_DOWN*dt);
    resolveX(e, e.vx*dt);
    resolveY(e, e.vy*dt);

    if(!e.alive) continue;
    if(AABB(player,e)){
      const prevBottom = player.y + player.h - player.vy*dt;
      if(player.vy>0 && prevBottom <= e.y+6){ e.alive=false; player.vy=-PHY.JUMP_V*0.6; beep(720,.06); }
      else damage(1);
    }
  }

  // death pit
  if(player.y > Level.h*TILE + 200) damage(3);

  // camera
  const cw=C.clientWidth;
  const tx = clamp(player.x - cw*0.42, 0, Level.w*TILE - cw);
  cam.x += (tx - cam.x) * 0.15; cam.y = 0;
}

function draw(t){
  const cw=C.clientWidth, ch=C.clientHeight;

  // crimson dusk gradient
  const wobble=Math.sin(t*.3)*16;
  const grad=g.createLinearGradient(0,ch+wobble,0,0);
  grad.addColorStop(0.00,'#8A2232');
  grad.addColorStop(0.33,'#9B2D3B');
  grad.addColorStop(0.66,'#A33C44');
  grad.addColorStop(1.00,'#FFB37E');
  g.fillStyle=grad; g.fillRect(0,0,cw,ch);

  // tiles
  const startTx=Math.floor(cam.x/TILE), endTx=Math.ceil((cam.x+cw)/TILE);
  for(let ty=0; ty<Level.h; ty++){
    for(let tx=startTx; tx<Math.min(endTx,Level.w); tx++){
      const id=Level.map[ty][tx]; if(!id) continue;
      const x=tx*TILE - cam.x, y=ty*TILE - cam.y;
      if(id===1){ g.fillStyle='#2e2a3a'; g.fillRect(x,y,TILE,TILE); }           // ground
      if(id===2){ g.fillStyle='#57455d'; g.fillRect(x+2,y+2,TILE-4,TILE-4); }   // brick
      if(id===3){ g.fillStyle='gold'; g.beginPath(); g.arc(x+16,y+16,7,0,Math.PI*2); g.fill(); } // coin
      if(id===4){ g.fillStyle='#b43636'; g.beginPath(); g.moveTo(x,y+TILE); g.lineTo(x+TILE/2,y+4); g.lineTo(x+TILE,y+TILE); g.closePath(); g.fill(); } // spikes
      if(id===5){ g.fillStyle='#c0ffb3'; g.fillRect(x+20,y-100,6,100); g.fillStyle='#45fd6c'; g.beginPath(); g.moveTo(x+26,y-96); g.lineTo(x+80,y-76); g.lineTo(x+26,y-56); g.closePath(); g.fill(); } // flag
      if(id===7){ g.fillStyle='#9b6bff'; g.fillRect(x+4,y+10,TILE-8,8); } // spring
    }
  }

  // moving platforms
  g.fillStyle='#4b5563';
  for(const p of movers) g.fillRect(Math.floor(p.x-cam.x), Math.floor(p.y-cam.y), p.w, p.h);

  // enemies
  g.fillStyle='#ff6e6e';
  for(const e of enemies){ if(!e.alive) continue; g.fillRect(Math.floor(e.x-cam.x), Math.floor(e.y-cam.y), e.w, e.h); }

  // player (simple ninja rect for now)
  g.fillStyle='#ffecef';
  g.fillRect(Math.floor(player.x-cam.x), Math.floor(player.y-cam.y), player.w, player.h);
}

function loop(now){
  const dt=Math.min(50, now-last)/1000; last=now;
  if(running) update(dt);
  draw(now/1000);
  requestAnimationFrame(loop);
}
let last=performance.now();
requestAnimationFrame(loop);
</script>
<script>
/* Wire up after loop so DOM is ready */
const UI={ title:document.getElementById('title'), hud:document.getElementById('hud'), pause:document.getElementById('pause'), win:document.getElementById('win') };
document.getElementById('playBtn').addEventListener('pointerdown', startGame, {once:true});
UI.title.addEventListener('pointerdown', (e)=>{ if(e.target===UI.title) startGame(); }, {once:true});
addEventListener('keydown', e=>{ if(!running) startGame(); }, {once:true});
document.getElementById('resumeBtn').onclick=()=>showPause(false);
document.getElementById('restartBtn').onclick=()=>{ showPause(false); restart(); };
document.getElementById('againBtn').onclick=()=>{ UI.win.classList.add('hide'); restart(); };
</script>
</body>
</html>
