<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>Ninja Worlds — Crimson Dusk</title>
<style>
  :root{--fg:#fff;--bg:#0c0a0f;--ui:rgba(255,255,255,.92)}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:14px/1.2 system-ui,-apple-system,Segoe UI,Inter}
  canvas{display:block;background:var(--bg);touch-action:none}
  .overlay{position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.5);backdrop-filter:blur(8px);z-index:10}
  .panel{background:rgba(20,20,26,.92);border:1px solid rgba(255,255,255,.15);padding:18px 20px;border-radius:14px;min-width:280px}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .btn{border:0;border-radius:10px;padding:10px 14px;font-weight:800;background:var(--ui);color:#000;cursor:pointer}
  .badge{background:rgba(0,0,0,.55);padding:6px 10px;border-radius:10px;font-weight:800}
  #hud{position:fixed;left:12px;top:10px;display:flex;gap:10px;z-index:6;flex-wrap:wrap}
  #tips{position:fixed;right:12px;top:10px;opacity:.9;background:rgba(0,0,0,.45);padding:6px 10px;border-radius:10px;z-index:6}
  .hide{display:none}
  /* Touch */
  .touch{position:fixed;left:12px;right:12px;bottom:16px;display:none;justify-content:space-between;align-items:flex-end;gap:12px;z-index:9}
  .pad{display:flex;gap:12px}
  .tbtn{width:70px;height:70px;border-radius:999px;border:0;background:rgba(255,255,255,.12);backdrop-filter:blur(10px);color:#fff;
        font:800 14px system-ui;display:grid;place-items:center;box-shadow:inset 0 0 0 2px rgba(255,255,255,.15)}
  .tbtn:active{transform:scale(.97)}
  .lg{width:86px;height:86px}
  @media (max-width: 820px){ .touch{display:flex} }
</style>
</head>
<body>
<canvas id="game"></canvas>

<!-- HUD -->
<div id="hud" class="hide">
  <div id="hp" class="badge">HP: ❤❤❤</div>
  <div id="coins" class="badge">Coins: 0/0</div>
  <div id="world" class="badge">World 1: Crimson Dusk</div>
</div>
<div id="tips" class="hide">Move: WASD/Arrows · Jump: Space · Attack: J · Dash: Shift · Pause: P/Esc</div>

<!-- Touch controls -->
<div class="touch" id="touch">
  <div class="pad">
    <button id="tLeft"  class="tbtn lg">◀︎</button>
    <button id="tRight" class="tbtn lg">▶︎</button>
  </div>
  <div class="pad">
    <button id="tJump"  class="tbtn lg">⤴︎</button>
    <button id="tAtk"   class="tbtn">Atk</button>
    <button id="tDash"  class="tbtn">Dash</button>
  </div>
</div>

<!-- Title -->
<div id="title" class="overlay">
  <div class="panel">
    <h2>Ninja Worlds — Crimson Dusk</h2>
    <p style="opacity:.85;margin:.2em 0 10px">Tap Play to begin.</p>
    <div class="row"><button class="btn" id="play">Play</button></div>
  </div>
</div>

<!-- Pause -->
<div id="pause" class="overlay hide">
  <div class="panel">
    <h2>Paused</h2>
    <div class="row">
      <button class="btn" id="resume">Resume</button>
      <button class="btn" id="restart">Restart</button>
      <button class="btn" id="menu">Menu</button>
    </div>
  </div>
</div>

<!-- Win -->
<div id="win" class="overlay hide">
  <div class="panel">
    <h2>Gate Cleared!</h2>
    <div class="row">
      <button class="btn" id="again">Replay</button>
      <button class="btn" id="back">Menu</button>
    </div>
  </div>
</div>

<script>
/* ========= Canvas (CSS-px physics) ========= */
const C=document.getElementById('game'), g=C.getContext('2d');
function resize(){
  const dpr=window.devicePixelRatio||1;
  C.width=Math.round(innerWidth*dpr);
  C.height=Math.round(innerHeight*dpr);
  C.style.width=innerWidth+'px';
  C.style.height=innerHeight+'px';
  g.setTransform(dpr,0,0,dpr,0,0); // draw in CSS px
}
resize(); addEventListener('resize',resize);

/* ========= Tiny audio ========= */
let ac=null; function ensureAC(){ if(!ac){ const AC=window.AudioContext||window.webkitAudioContext; if(AC) ac=new AC(); } return ac; }
function beep(f=660,d=.05){ try{ const ac=ensureAC(); if(!ac) return; const o=ac.createOscillator(), v=ac.createGain(); o.type='square'; o.frequency.value=f; v.gain.value=.05; o.connect(v); v.connect(ac.destination); o.start(); o.stop(ac.currentTime+d);}catch(_){} }

/* ========= Tiles & level =========
   0 empty, 1 ground, 2 brick, 3 coin, 4 spikes, 5 flag, 7 spring, 9 checkpoint */
const TILE=32; const solid=id=>id===1||id===2||id===9; const deadly=id=>id===4;
function makeLevel(w,h){ const L=[]; for(let y=0;y<h;y++){ const r=new Array(w).fill(0); if(y>=h-3) r.fill(1); L.push(r);} return L; }
function setT(L,tx,ty,id){ if(L[ty]&&L[ty][tx]!=null) L[ty][tx]=id; }
function stamp(L,tx,ty,w,id){ for(let i=0;i<w;i++) setT(L,tx+i,ty,id); }
function carveHole(L,ty,from,to){ for(let x=from;x<=to;x++) L[ty][x]=0; }

function buildLevel(){
  const W=170,H=20, map=makeLevel(W,H);
  // holes and platforms
  carveHole(map,H-3,22,24); carveHole(map,H-3,58,60); carveHole(map,H-3,96,98);
  stamp(map,14,H-6,6,2); setT(map,16,H-7,3); setT(map,18,H-7,3);
  stamp(map,34,H-8,5,2); setT(map,36,H-9,3);
  stamp(map,52,H-7,6,2); setT(map,54,H-8,3);
  setT(map,40,H-4,7);                      // spring
  setT(map,46,H-4,4);                      // spikes
  setT(map,70,H-4,9);                      // checkpoint
  setT(map,W-6,H-4,5);                     // flag
  // coins sprinkle
  for(let x=8;x<W-8;x+=10){ setT(map,H-6,3,3); }
  return {w:W,h:H,map,name:'World 1: Crimson Dusk'};
}
function tileAt(L,px,py){
  const tx=Math.floor(px/TILE), ty=Math.floor(py/TILE);
  if(ty<0||ty>=L.h||tx<0||tx>=L.w) return 0;
  return L.map[ty][tx];
}

/* ========= State ========= */
let Level=null, totalCoins=0, running=false, cam={x:0,y:0};
const HUD={hp:qs('#hp'),coins:qs('#coins'),world:qs('#world')};
const UI={title:qs('#title'),pause:qs('#pause'),win:qs('#win'),hud:qs('#hud'),tips:qs('#tips')};
function qs(s){return document.querySelector(s);}

/* ========= Player (Mario-ish tuning) ========= */
const P={x:0,y:0,w:22,h:28,vx:0,vy:0,face:1,on:false,wasOn:false,jumps:0,maxJ:1,dashCd:0,attackT:0,hp:3,iFrames:0,coins:0};
const RUN=320, AIR_ACCEL=2600, GROUND_ACCEL=3600, GROUND_DECEL=5200, AIR_DECEL=600;
const JUMP_V=700, GRAV_UP=1700, GRAV_DOWN=2400, MAX_FALL=1650, DASH=520;
const COYOTE_MAX=0.10, JUMP_BUF=0.14; let coyote=0, jbuf=0;

/* ========= Enemies & boss ========= */
let enemies=[]; function buildEnemies(){ enemies.length=0; for(let x=16;x<Level.w-12;x+=16){ enemies.push({x:x*TILE+4,y:(Level.h-4)*TILE-26,w:20,h:26,vx:60*(Math.random()<.5?-1:1),vy:0,alive:true}); } }
let boss=null; function spawnBoss(){ const x=(Level.w-12)*TILE, y=(Level.h-6)*TILE-40; boss={x,y,w:44,h:44,vx:-90,vy:0,hp:12,iFrames:0,on:false,alive:true}; }

/* ========= Input (desktop + touch) ========= */
const keys=Object.create(null);
addEventListener('keydown',e=>{
  const k=e.key.toLowerCase();
  if([' ','arrowleft','arrowright','arrowup','arrowdown'].includes(e.key)) e.preventDefault();
  keys[k]=true;
  if(k==='p'||e.key==='Escape'){ togglePause(true); }
});
addEventListener('keyup',e=>{ keys[e.key.toLowerCase()]=false; });
addEventListener('blur',()=>{ for(const k in keys) keys[k]=false; P.vx=0; });

const isTouch='ontouchstart' in window || navigator.maxTouchPoints>0;
if(isTouch) document.getElementById('touch').style.display='flex';
function bindHold(id,down,up){
  const el=document.getElementById(id);
  const press=e=>{e.preventDefault();down();};
  const lift =e=>{e.preventDefault();up();};
  ['pointerdown','touchstart','mousedown'].forEach(t=>el.addEventListener(t,press));
  ['pointerup','pointercancel','touchend','mouseleave','mouseup'].forEach(t=>el.addEventListener(t,lift));
}
bindHold('tLeft', ()=>{keys.a=keys.arrowleft=true;}, ()=>{keys.a=keys.arrowleft=false;});
bindHold('tRight',()=>{keys.d=keys.arrowright=true;},()=>{keys.d=keys.arrowright=false;});
bindHold('tJump', ()=>{keys[' ']=keys.space=true;}, ()=>{keys[' ']=keys.space=false;});
bindHold('tAtk',  ()=>{keys.j=true;}, ()=>{keys.j=false;});
bindHold('tDash', ()=>{keys.shift=true;}, ()=>{keys.shift=false;});

/* ========= Collisions ========= */
function resolveX(ent,dx){
  ent.x+=dx;
  const Lft=Math.floor(ent.x/TILE), Rgt=Math.floor((ent.x+ent.w-1)/TILE);
  const Top=Math.floor(ent.y/TILE),  Bot=Math.floor((ent.y+ent.h-1)/TILE);
  for(let ty=Top; ty<=Bot; ty++){
    for(let tx=Lft; tx<=Rgt; tx++){
      const id=tileAt(Level,tx*TILE+1,ty*TILE+1);
      if(solid(id)){
        if(dx>0) ent.x=tx*TILE-ent.w; else ent.x=(tx+1)*TILE;
        ent.vx=0;
      }
      if(ent===P && deadly(id)) damage(1);
    }
  }
}
function resolveY(ent,dy){
  ent.y+=dy;
  const Lft=Math.floor(ent.x/TILE), Rgt=Math.floor((ent.x+ent.w-1)/TILE);
  const Top=Math.floor(ent.y/TILE),  Bot=Math.floor((ent.y+ent.h-1)/TILE);
  let on=false;
  for(let ty=Top; ty<=Bot; ty++){
    for(let tx=Lft; tx<=Rgt; tx++){
      const id=tileAt(Level,tx*TILE+1,ty*TILE+1);
      if(solid(id)){
        if(dy>0){ ent.y=ty*TILE-ent.h; ent.vy=0; on=true; }
        else     { ent.y=(ty+1)*TILE; if(ent.vy<0) ent.vy=0; }
      }
      if(ent===P){
        if(id===3){ Level.map[ty][tx]=0; P.coins++; beep(880,.05); setHUD(); }
        if(id===7 && dy>0){ P.vy=-JUMP_V*1.2; beep(760,.07); }
        if(id===9){ /* checkpoint visual only in this basic build */ }
        if(id===5 && !boss){ win(); }
        if(deadly(id)) damage(1);
      }
    }
  }
  ent.on=on;
}

/* ========= HUD / flow ========= */
function setHUD(){ HUD.hp.textContent='HP: '+'❤'.repeat(P.hp)+'♡'.repeat(Math.max(0,3-P.hp)); HUD.coins.textContent='Coins: '+P.coins+'/'+totalCoins; HUD.world.textContent=Level.name; }
function damage(n){ if(P.iFrames>0) return; P.hp=Math.max(0,P.hp-n); P.iFrames=.8; P.vy=-320; beep(220,.05); setHUD(); if(P.hp===0) respawn(); }
function respawn(){ P.x=3*TILE; P.y=(Level.h-4)*TILE-28; P.vx=P.vy=0; P.hp=3; P.iFrames=0; setHUD(); }
function win(){ running=false; UI.win.classList.remove('hide'); }
function togglePause(show){ if(show){ running=false; UI.pause.classList.remove('hide'); } else { UI.pause.classList.add('hide'); running=true; } }

/* ========= Start / restart ========= */
function recalcCoins(){ totalCoins=0; for(const r of Level.map) for(const v of r) if(v===3) totalCoins++; }
function startGame(){
  Level = buildLevel();
  buildEnemies();
  spawnBoss();

  // spawn on ground at start
  P.x=3*TILE; P.y=(Level.h-4)*TILE-28;
  P.vx=P.vy=0; P.hp=3; P.iFrames=0; P.jumps=0;
  recalcCoins(); setHUD();

  // camera start
  cam.x=Math.max(0, P.x - C.clientWidth*0.4); cam.y=0;

  UI.title.classList.add('hide'); UI.hud.classList.remove('hide'); UI.tips.classList.remove('hide');
  running=true;
}

/* ========= Update ========= */
function update(dt){
  if(!running) return;
  const left=keys.a||keys.arrowleft, right=keys.d||keys.arrowright, jump=keys[' ']||keys.space, dash=keys.shift, atk=keys.j;

  P.wasOn=P.on; P.on=false;

  // timers
  coyote = Math.min(COYOTE_MAX, P.wasOn? COYOTE_MAX : Math.max(0,coyote-dt));
  jbuf = Math.max(0,jbuf-dt); if(jump && jbuf<=0) jbuf=JUMP_BUF;
  P.iFrames=Math.max(0,P.iFrames-dt);
  if(atk && P.attackT<=0){ P.attackT=.12; beep(520,.05); }
  P.attackT=Math.max(0,P.attackT-dt);

  // horizontal
  const ax=(right?1:0)-(left?1:0);
  P.vx += ax * (P.wasOn? GROUND_ACCEL : AIR_ACCEL) * dt;
  P.vx = clamp(P.vx, -RUN, RUN);
  if(ax===0 && P.wasOn){
    const dec=Math.sign(P.vx)*Math.min(Math.abs(P.vx), GROUND_DECEL*dt);
    P.vx -= dec; if(Math.abs(P.vx)<0.08) P.vx=0;
  } else if(ax===0 && !P.wasOn){
    const dec=Math.sign(P.vx)*Math.min(Math.abs(P.vx), AIR_DECEL*dt);
    P.vx -= dec;
  }
  if(right) P.face=1; if(left) P.face=-1;

  // jump
  if(jbuf>0 && (coyote>0 || (!P.wasOn && P.jumps<P.maxJ))){
    P.vy = -JUMP_V; P.jumps = P.wasOn ? 1 : P.jumps+1;
    jbuf=0; coyote=0; keys[' ']=keys['space']=false; beep(640,.05);
  }
  // variable jump height
  if(!(keys[' ']||keys['space']) && P.vy<-180) P.vy=-180;

  // dash
  if(dash && P.dashCd<=0){ P.vx+=DASH*P.face; P.dashCd=.35; beep(440,.05); }
  P.dashCd=Math.max(0,P.dashCd-dt);

  // gravity & integrate
  P.vy += (P.vy<0? GRAV_UP : GRAV_DOWN)*dt; if(P.vy>MAX_FALL) P.vy=MAX_FALL;
  resolveX(P, P.vx*dt);
  resolveY(P, P.vy*dt);
  if(P.on){ P.jumps=0; coyote=COYOTE_MAX; }

  // enemies
  for(const e of enemies){
    if(!e.alive) continue;
    const aheadX=e.x+(e.vx>0? e.w+1:-1), aheadY=e.y+e.h/2;
    const groundAhead=tileAt(Level, e.x+e.w/2+(e.vx>0?14:-14), e.y+e.h+2);
    const wallAhead  =tileAt(Level, aheadX, aheadY);
    if(solid(wallAhead) || !solid(groundAhead)) e.vx *= -1;
    e.vy += GRAV_DOWN*dt; if(e.vy>MAX_FALL) e.vy=MAX_FALL;
    resolveX(e, e.vx*dt);
    resolveY(e, e.vy*dt);
    if(AABB(P,e)){
      const prevBottom=P.y+P.h-P.vy*dt;
      if(P.vy>0 && prevBottom<=e.y+6){ e.alive=false; P.vy=-JUMP_V*0.7; beep(700,.05);}
      else damage(1);
    }
    if(P.attackT>0){
      const sword={x:P.x+(P.face>0?P.w:-18),y:P.y+6,w:18,h:16};
      if(AABB(sword,e)) e.alive=false;
    }
  }

  // boss
  if(!boss && P.x>(Level.w-20)*TILE) spawnBoss();
  if(boss && boss.alive){
    boss.iFrames=Math.max(0,boss.iFrames-dt);
    if(Math.abs(P.x-boss.x)<320) boss.vx=(P.x<boss.x?-120:120);
    boss.vy += GRAV_DOWN*dt; if(boss.vy>MAX_FALL) boss.vy=MAX_FALL;
    resolveX(boss,boss.vx*dt);
    resolveY(boss,boss.vy*dt);
    if(AABB(P,boss)) damage(1);
    if(P.attackT>0){
      const sword={x:P.x+(P.face>0?P.w:-18),y:P.y+6,w:18,h:16};
      if(AABB(sword,boss)) { boss.hp=Math.max(0,boss.hp-1); boss.iFrames=.4; beep(480,.07); if(boss.hp===0){ boss.alive=false; win(); } }
    }
    const prevBottom=P.y+P.h-P.vy*dt;
    if(AABB(P,boss) && P.vy>0 && prevBottom<=boss.y+8){ boss.hp=Math.max(0,boss.hp-1); P.vy=-JUMP_V*0.7; if(boss.hp===0){ boss.alive=false; win(); } }
  }

  // death pit
  if(P.y>Level.h*TILE+200) damage(3);

  // camera
  const cw=C.clientWidth, worldW=Level.w*TILE;
  const tx=Math.max(0, Math.min(worldW-cw, P.x - cw*0.4));
  cam.x += (tx - cam.x) * 0.14; cam.y=0;
}

/* ========= Render ========= */
function draw(t){
  const cw=C.clientWidth, ch=C.clientHeight;
  // crimson dusk gradient + parallax hills
  const grad=g.createLinearGradient(0,ch,0,0);
  grad.addColorStop(0,'#8A2232'); grad.addColorStop(.33,'#9B2D3B'); grad.addColorStop(.66,'#A33C44'); grad.addColorStop(1,'#FFB37E');
  g.fillStyle=grad; g.fillRect(0,0,cw,ch);
  drawHills('#33111a', .10, 110);
  drawHills('#4a1a24', .18,  80);
  drawHills('#642233', .28,  48);

  // tiles in view
  const startTx=Math.floor(cam.x/TILE), endTx=Math.ceil((cam.x+cw)/TILE);
  for(let ty=0; ty<Level.h; ty++){
    for(let tx=startTx; tx<Math.min(endTx,Level.w); tx++){
      const id=Level.map[ty][tx]; if(id===0) continue;
      const x=tx*TILE - cam.x, y=ty*TILE;
      if(id===1){ g.fillStyle='#2e2a3a'; g.fillRect(x,y,TILE,TILE); }
      if(id===2){ g.fillStyle='#57455d'; g.fillRect(x+2,y+2,TILE-4,TILE-4); }
      if(id===3){ g.fillStyle='gold'; g.beginPath(); g.arc(x+16,y+16,7,0,Math.PI*2); g.fill(); }
      if(id===4){ g.fillStyle='#b43636'; g.beginPath(); g.moveTo(x,y+TILE); g.lineTo(x+TILE/2,y+4); g.lineTo(x+TILE,y+TILE); g.closePath(); g.fill(); }
      if(id===5){ g.fillStyle='#c0ffb3'; g.fillRect(x+20,y-100,6,100); g.fillStyle='#45fd6c'; g.beginPath(); g.moveTo(x+26,y-96); g.lineTo(x+80,y-76); g.lineTo(x+26,y-56); g.closePath(); g.fill(); }
      if(id===7){ g.fillStyle='#9b6bff'; g.fillRect(x+4,y+10,TILE-8,8); }
      if(id===9){ g.strokeStyle='rgba(255,255,255,.7)'; g.strokeRect(x+10,y+8,12,16); }
    }
  }

  // enemies
  g.fillStyle='#ff6e6e';
  for(const e of enemies){ if(!e.alive) continue; g.fillRect(Math.floor(e.x-cam.x), Math.floor(e.y), e.w, e.h); }

  // boss
  if(boss && boss.alive){ g.fillStyle='#ffd3d3'; g.fillRect(Math.floor(boss.x-cam.x), Math.floor(boss.y), boss.w, boss.h); }

  // player (blink on damage)
  if(!(P.iFrames>0 && ((t*12|0)%2===0))){
    g.fillStyle='#ffecef';
    g.fillRect(Math.floor(P.x-cam.x), Math.floor(P.y), P.w, P.h);
  }
}
function drawHills(color, parallax, h){
  const cw=C.clientWidth, ch=C.clientHeight;
  g.save(); g.translate(-cam.x*parallax,0); g.fillStyle=color;
  for(let i=-1;i<12;i++){
    const x=i*240;
    g.beginPath(); g.moveTo(x,ch);
    g.quadraticCurveTo(x+120, ch-h-40, x+240, ch);
    g.closePath(); g.fill();
  }
  g.restore();
}

/* ========= Loop ========= */
let last=performance.now();
function loop(now){
  const dt=Math.min(50, now-last)/1000; last=now;
  if(running) update(dt);
  draw(now/1000);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ========= Utils ========= */
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function AABB(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }

/* ========= UI wiring ========= */
qs('#play').addEventListener('click', ()=>{ try{const ac=ensureAC(); if(ac&&ac.state==='suspended') ac.resume(); }catch(_){ } startGame(); }, {once:true});
qs('#resume').onclick = ()=> togglePause(false);
qs('#restart').onclick= ()=>{ togglePause(false); startGame(); };
qs('#menu').onclick   = ()=>{ togglePause(false); running=false; UI.title.classList.remove('hide'); UI.hud.classList.add('hide'); UI.tips.classList.add('hide'); };
qs('#again').onclick  = ()=>{ UI.win.classList.add('hide'); startGame(); };
qs('#back').onclick   = ()=>{ UI.win.classList.add('hide'); running=false; UI.title.classList.remove('hide'); UI.hud.classList.add('hide'); UI.tips.classList.add('hide'); };
</script>
</body>
</html>
