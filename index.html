<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Ninja Platformer ‚Äî Checkpoints, Platforms, Gate + Editor</title>
<style>
  html,body{margin:0;height:100%;background:#1a0f0f;color:#fff;font:14px/1.2 system-ui,-apple-system,Segoe UI,Inter}
  canvas{display:block;margin:0 auto;background:#1a0f0f}
  #hud{position:fixed;left:12px;top:10px;display:flex;gap:10px;z-index:10}
  .badge{background:rgba(0,0,0,.55);padding:6px 10px;border-radius:10px;font-weight:800}
  #tips{position:fixed;right:12px;top:10px;opacity:.9;background:rgba(0,0,0,.45);padding:6px 10px;border-radius:10px;z-index:10}
  #editHelp{position:fixed;left:12px;bottom:12px;opacity:.9;background:rgba(0,0,0,.45);padding:6px 10px;border-radius:10px;display:none;z-index:10}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud">
  <div id="hp" class="badge">HP: ‚ù§‚ù§‚ù§</div>
  <div id="coins" class="badge">Coins: 0</div>
  <div id="power" class="badge">Power: ‚Äî</div>
  <div id="key" class="badge">Key: ‚úñ</div>
</div>
<div id="tips">Move: WASD/Arrows ¬∑ Jump: Space ¬∑ Attack: J ¬∑ Dash: Shift ¬∑ Toggle Editor: E</div>
<div id="editHelp">Editor: [0..6,9,10,11] pick tile ¬∑ L-click place ¬∑ R-click erase ¬∑ G grid ¬∑ S save (console)</div>

<script>
/* ===== Canvas (CSS px physics) ===== */
const C = document.getElementById('game'), g = C.getContext('2d');
function resize(){
  const dpr = devicePixelRatio||1;
  C.width  = Math.round(innerWidth * dpr);
  C.height = Math.round(innerHeight* dpr);
  C.style.width = innerWidth+'px';
  C.style.height= innerHeight+'px';
  g.setTransform(dpr,0,0,dpr,0,0);
}
resize(); addEventListener('resize', resize);

/* ===== Tiny beep SFX ===== */
function beep(f=660, d=.06){ try{
  const AC=window.AudioContext||window.webkitAudioContext; if(!AC) return;
  if(!window._ac) window._ac=new AC(); const ac=_ac, o=ac.createOscillator(), v=ac.createGain();
  o.type='square'; o.frequency.value=f; v.gain.value=.05; o.connect(v); v.connect(ac.destination);
  o.start(); o.stop(ac.currentTime+d);
}catch(_){} }

/* ===== World / Tiles ===== */
const TILE=32, LEVEL_W=172, LEVEL_H=20;
// 0 empty, 1 ground, 2 brick, 3 coin, 4 spikes, 5 flag, 6 scroll (double jump), 7 spring, 9 checkpoint, 10 gate, 11 key
const Level=[];
for(let y=0;y<LEVEL_H;y++){
  const row = new Array(LEVEL_W).fill(0);
  if(y>=LEVEL_H-3) row.fill(1);          // base ground band
  Level.push(row);
}
// carve pits
for(let x=18;x<=20;x++) Level[LEVEL_H-3][x]=0;
for(let x=52;x<=55;x++) Level[LEVEL_H-3][x]=0;
for(let x=96;x<=98;x++) Level[LEVEL_H-3][x]=0;
// ledges + goodies
function ledge(tx,ty,w){ for(let i=0;i<w;i++) Level[ty][tx+i]=2; }
function coin(tx,ty){ Level[ty][tx]=3; }
function spikes(tx,ty){ Level[ty][tx]=4; }
function scroll(tx,ty){ Level[ty][tx]=6; }
function spring(tx,ty){ Level[ty][tx]=7; }
function checkpoint(tx,ty){ Level[ty][tx]=9; }
function gate(tx,ty){ Level[ty][tx]=10; }
function keytile(tx,ty){ Level[ty][tx]=11; }

ledge(10,12,6); coin(12,11); coin(14,11);
ledge(28,10,5); coin(30,9);
ledge(44, 8,5); coin(46,7);
ledge(64,11,6); coin(66,10);
ledge(82, 9,6); coin(84,8);
ledge(104,7,6); coin(106,6); scroll(109,6);
spring(37, LEVEL_H-4); spring(72, LEVEL_H-4);
spikes(60, LEVEL_H-4); spikes(61, LEVEL_H-4); spikes(62, LEVEL_H-4);
checkpoint(25, LEVEL_H-4);
keytile(140, LEVEL_H-4);
gate(158, LEVEL_H-4);
Level[LEVEL_H-4][LEVEL_W-6]=5; // goal flag

let totalCoins=0; for(const r of Level) for(const v of r) if(v===3) totalCoins++;

/* ===== Helpers ===== */
const solid  = id => id===1||id===2||id===10;
const deadly = id => id===4;
function tileAt(px,py){
  const tx=Math.floor(px/TILE), ty=Math.floor(py/TILE);
  if(ty<0||ty>=LEVEL_H||tx<0||tx>=LEVEL_W) return 0;
  return Level[ty][tx];
}

/* ===== Entities ===== */
const cam={x:0,y:0}, CAM_LERP=0.15, CAM_OFF=0.4;
const player={
  x:3*TILE, y:(LEVEL_H-4)*TILE-28, w:22, h:28,
  vx:0, vy:0, face:1,
  on:false, wasOn:false,
  jumps:0, maxJ:1, dashCd:0, attackT:0,
  hp:3, iFrames:0, coins:0, power:false, key:false,
  spawnX:3*TILE, spawnY:(LEVEL_H-4)*TILE-28
};
const enemies=[];
for(let i=14;i<LEVEL_W-12;i+=16){
  enemies.push({x:i*TILE+4,y:(LEVEL_H-4)*TILE-26,w:20,h:26,vx:60*(Math.random()<.5?-1:1),vy:0,alive:true});
}

/* ===== Moving Platforms =====
   Each platform moves between waypoints; player can ride them. */
const platforms=[
  // horizontal shuttle
  {x:48*TILE, y:(LEVEL_H-7)*TILE, w:64, h:12, t:0, speed:70, path:[{x:48*TILE,y:(LEVEL_H-7)*TILE},{x:56*TILE,y:(LEVEL_H-7)*TILE}], ix:0},
  // vertical elevator
  {x:75*TILE, y:(LEVEL_H-10)*TILE, w:64, h:12, t:0, speed:70, path:[{x:75*TILE,y:(LEVEL_H-12)*TILE},{x:75*TILE,y:(LEVEL_H-6)*TILE}], ix:0},
];

/* ===== Input ===== */
const keys=Object.create(null);
addEventListener('keydown',e=>{
  const k=e.key.toLowerCase(); if([' ','arrowleft','arrowright','arrowup','arrowdown'].includes(e.key)) e.preventDefault();
  keys[k]=true;
});
addEventListener('keyup',e=>{ keys[e.key.toLowerCase()]=false; });
addEventListener('blur', ()=>{ for(const k in keys) keys[k]=false; player.vx=0; });

/* ===== Physics ===== */
const GRAV=2200, RUN=380, AIR_ACCEL=2400, DECEL=5200, JUMP_V=650, MAX_FALL=1400, DASH=520;

/* ===== Collisions vs tiles (axis separated) ===== */
function resolveX(ent, dx){
  ent.x += dx;
  const L = Math.floor(ent.x/TILE);
  const R = Math.floor((ent.x+ent.w-1)/TILE);
  const T = Math.floor(ent.y/TILE);
  const B = Math.floor((ent.y+ent.h-1)/TILE);
  for(let ty=T; ty<=B; ty++){
    for(let tx=L; tx<=R; tx++){
      const id = tileAt(tx*TILE+1, ty*TILE+1);
      if(solid(id)){
        if(dx>0) ent.x = tx*TILE - ent.w; else ent.x = (tx+1)*TILE;
        ent.vx = 0;
      }
      if(ent===player){
        if(deadly(id)) damage(1);
      }
    }
  }
}
function resolveY(ent, dy){
  ent.y += dy;
  const L = Math.floor(ent.x/TILE);
  const R = Math.floor((ent.x+ent.w-1)/TILE);
  const T = Math.floor(ent.y/TILE);
  const B = Math.floor((ent.y+ent.h-1)/TILE);
  let on=false;
  for(let ty=T; ty<=B; ty++){
    for(let tx=L; tx<=R; tx++){
      const id = tileAt(tx*TILE+1, ty*TILE+1);
      if(solid(id)){
        if(dy>0){ ent.y = ty*TILE - ent.h; ent.vy=0; on=true; }
        else     { ent.y = (ty+1)*TILE; if(ent.vy<0) ent.vy=0; }
      }
      if(ent===player){
        if(id===3){ Level[ty][tx]=0; player.coins++; beep(880,.06); updateHUD(); }
        if(id===6){ Level[ty][tx]=0; player.maxJ=2; player.power=true; beep(660,.1); updateHUD(); }
        if(id===7 && dy>0){ player.vy=-JUMP_V*1.2; beep(760,.08); }
        if(id===9){ player.spawnX = (tx*TILE+4); player.spawnY = (ty*TILE - player.h - 2); } // checkpoint
        if(id===11){ Level[ty][tx]=0; player.key=true; beep(520,.12); updateHUD(); }
        if(id===10 && player.key){ Level[ty][tx]=0; beep(480,.08); } // open gate on touch if key
        if(id===5){ win(); }
        if(deadly(id)) damage(1);
      }
    }
  }
  ent.on = on;
}

/* ===== HUD ===== */
function updateHUD(){
  document.getElementById('hp').textContent='HP: '+ '‚ù§'.repeat(player.hp)+'‚ô°'.repeat(Math.max(0,3-player.hp));
  document.getElementById('coins').textContent='Coins: '+player.coins+'/'+totalCoins;
  document.getElementById('power').textContent='Power: ' + (player.power?'Shadow x2':'‚Äî');
  document.getElementById('key').textContent='Key: ' + (player.key?'‚úî':'‚úñ');
}
function damage(n){
  if(player.iFrames>0) return;
  player.hp=Math.max(0,player.hp-n); player.iFrames=1.0; player.vy=-320; beep(220,.06);
  if(player.hp===0) respawn(); updateHUD();
}
function respawn(){
  // if checkpoint touched, respawn there; else reset start
  player.x=player.spawnX; player.y=player.spawnY; player.vx=player.vy=0; player.hp=3; player.iFrames=0;
}
function win(){ alert('You Win! üéâ'); location.reload(); }

/* ===== Moving platform logic + riding ===== */
function movePlatforms(dt){
  platforms.forEach(p=>{
    const curr = p.path[p.ix], next = p.path[(p.ix+1)%p.path.length];
    const dx = Math.sign(next.x - p.x) * Math.min(Math.abs(next.x - p.x), p.speed*dt);
    const dy = Math.sign(next.y - p.y) * Math.min(Math.abs(next.y - p.y), p.speed*dt);
    p.x += dx; p.y += dy;
    if(Math.abs(p.x-next.x)<1 && Math.abs(p.y-next.y)<1) p.ix=(p.ix+1)%p.path.length;

    // player riding / collision from top
    const futureBottom = player.y + player.h + player.vy*dt;
    const wasAbove = (player.y + player.h) <= p.y + 6;
    const overlap = AABB(player, {x:p.x,y:p.y,w:p.w,h:p.h});
    if(overlap && player.vy>=0 && wasAbove){
      player.y = p.y - player.h; player.vy=0; player.on=true;
      // carry horizontally
      player.x += dx;
    }else if(overlap){
      // push out sideways if intersect
      if(player.x + player.w/2 < p.x + p.w/2) player.x = p.x - player.w;
      else player.x = p.x + p.w;
      player.vx = 0;
    }
  });
}

/* ===== Update ===== */
function update(dt){
  const left=keys.a||keys.arrowleft, right=keys.d||keys.arrowright, jump=keys[' ']||keys.space, dash=keys.shift, atk=keys.j;

  player.wasOn = player.on; player.on=false;

  // side accel
  const ax=(right?1:0)-(left?1:0);
  player.vx += ax * (player.wasOn ? RUN*12 : AIR_ACCEL) * dt;
  player.vx = Math.max(-RUN, Math.min(RUN, player.vx));
  // decel
  if(ax===0 && player.wasOn){
    const dec = Math.sign(player.vx)*Math.min(Math.abs(player.vx), DECEL*dt);
    player.vx -= dec; if(Math.abs(player.vx)<0.15) player.vx=0;
  }
  if(right) player.face=1; if(left) player.face=-1;

  // wall check
  let touchingWall=false;
  const sideX = player.x + (player.face>0?player.w+1:-1);
  for(let y=player.y; y<player.y+player.h; y+=Math.max(1,player.h-1)){
    if(solid(tileAt(sideX,y))){ touchingWall=true; break; }
  }
  if(!player.wasOn && touchingWall && (left||right) && player.vy>0) player.vy=Math.min(player.vy,240);

  // jump / double jump
  if(jump){
    if(player.wasOn){ player.vy=-JUMP_V; player.jumps=1; keys[' ']=keys['space']=false; beep(620,.06); }
    else if(player.power && player.jumps<player.maxJ){ player.vy=-JUMP_V*0.95; player.jumps++; keys[' ']=keys['space']=false; beep(620,.06); }
    else if(touchingWall){ player.vy=-JUMP_V*0.95; player.vx=-player.face*(RUN*0.9); keys[' ']=keys['space']=false; beep(620,.06); }
  }

  // dash
  if(dash && player.dashCd<=0){ player.vx += DASH*player.face; player.dashCd=.35; beep(440,.05); }
  player.dashCd=Math.max(0,player.dashCd - dt);

  // attack
  if(atk && player.attackT<=0){ player.attackT=.12; beep(520,.05); }
  player.attackT=Math.max(0, player.attackT - dt);

  // gravity
  player.vy += GRAV*dt; if(player.vy>MAX_FALL) player.vy=MAX_FALL;

  // integrate + collide with tiles
  resolveX(player, player.vx*dt);
  resolveY(player, player.vy*dt);
  if(player.on) player.jumps=0;

  // moving platforms after tiles (so we can land on them)
  movePlatforms(dt);

  // enemies
  for(const e of enemies){
    if(!e.alive) continue;
    const aheadX = e.x + (e.vx>0? e.w+1 : -1);
    const aheadY = e.y + e.h/2;
    const groundAhead = tileAt(e.x + e.w/2 + (e.vx>0?14:-14), e.y + e.h + 2);
    const wallAhead   = tileAt(aheadX, aheadY);
    if(solid(wallAhead) || !solid(groundAhead)) e.vx *= -1;

    e.vy += GRAV*dt; if(e.vy>MAX_FALL) e.vy=MAX_FALL;
    resolveX(e, e.vx*dt);
    resolveY(e, e.vy*dt);

    // fight
    if(AABB(player, e)){
      const prevBottom = player.y + player.h - player.vy*dt;
      if(player.vy>0 && prevBottom <= e.y+6){ e.alive=false; player.vy=-JUMP_V*0.7; beep(700,.06); }
      else{ damage(1); }
    }
    if(player.attackT>0){
      const sword = {x: player.x + (player.face>0?player.w:-18), y: player.y+6, w:18, h:16};
      if(AABB(sword,e)) e.alive=false;
    }
  }

  // death pit
  if(player.y > LEVEL_H*TILE + 200) damage(3);

  // timers
  player.iFrames=Math.max(0,player.iFrames - dt);

  // camera
  const cw=C.clientWidth, wpx=LEVEL_W*TILE;
  const tx = Math.max(0, Math.min(player.x - cw*CAM_OFF, wpx - cw));
  cam.x += (tx - cam.x) * CAM_LERP; cam.y=0;
}

/* ===== Render (Crimson Dusk Parallax) ===== */
function draw(t){
  const cw=C.clientWidth, ch=C.clientHeight;

  // sky gradient
  const wobble=Math.sin(t*0.3)*16;
  const grad=g.createLinearGradient(0,ch+wobble,0,0);
  grad.addColorStop(0.00,'#8A2232');
  grad.addColorStop(0.33,'#9B2D3B');
  grad.addColorStop(0.66,'#A33C44');
  grad.addColorStop(1.00,'#FFB37E');
  g.fillStyle=grad; g.fillRect(0,0,cw,ch);

  // parallax hills
  drawHills('#33111a', 0.08, 120);
  drawHills('#4a1a24', 0.16, 80);
  drawHills('#642233', 0.28, 48);

  // visible tile window
  const startTx=Math.floor(cam.x/TILE);
  const endTx=Math.ceil((cam.x+cw)/TILE);

  // tiles
  for(let ty=0; ty<LEVEL_H; ty++){
    for(let tx=startTx; tx<Math.min(endTx,LEVEL_W); tx++){
      const id=Level[ty][tx]; if(id===0) continue;
      const x=tx*TILE - cam.x, y=ty*TILE - cam.y;
      if(id===1){ g.fillStyle='#2e2a3a'; g.fillRect(x,y,TILE,TILE); }
      if(id===2){ g.fillStyle='#57455d'; g.fillRect(x+2,y+2,TILE-4,TILE-4); }
      if(id===3){ drawCoin(x+11,y+11); }
      if(id===4){ g.fillStyle='#b43636'; g.beginPath(); g.moveTo(x,y+TILE); g.lineTo(x+TILE/2,y+4); g.lineTo(x+TILE,y+TILE); g.closePath(); g.fill(); }
      if(id===5){ // flag
        g.fillStyle='#c0ffb3'; g.fillRect(x+20,y-100,6,100);
        g.fillStyle='#45fd6c'; g.beginPath(); g.moveTo(x+26,y-96); g.lineTo(x+80,y-76); g.lineTo(x+26,y-56); g.closePath(); g.fill();
      }
      if(id===6){ g.fillStyle='#7ce8ff'; g.fillRect(x+10,y+10,12,12); } // scroll
      if(id===7){ g.fillStyle='#9b6bff'; g.fillRect(x+4,y+10,TILE-8,8); } // spring
      if(id===9){ g.fillStyle='#ff8a7a'; g.fillRect(x+10,y+6,12,20); } // checkpoint lantern
      if(id===10){ g.fillStyle='#3a1a24'; g.fillRect(x+2,y+2,TILE-4,TILE-4); } // gate
      if(id===11){ g.fillStyle='#ffd37a'; g.fillRect(x+8,y+8,16,16); } // key
    }
  }

  // moving platforms
  g.fillStyle='#4b5563';
  platforms.forEach(p=>{ g.fillRect(Math.floor(p.x-cam.x), Math.floor(p.y-cam.y), p.w, p.h); });

  // enemies
  g.fillStyle='#ff6e6e';
  for(const e of enemies){ if(!e.alive) continue;
    g.fillRect(Math.floor(e.x-cam.x), Math.floor(e.y-cam.y), e.w, e.h);
  }

  // player (blink on iframes)
  if(!(player.iFrames>0 && ((t*10|0)%2===0))){
    g.fillStyle='#ffecef';
    g.fillRect(Math.floor(player.x-cam.x), Math.floor(player.y-cam.y), player.w, player.h);
  }

  // sword flash
  if(player.attackT>0){
    g.fillStyle='rgba(255,255,255,.25)';
    const sx = player.x + (player.face>0?player.w:-18) - cam.x;
    const sy = player.y+6 - cam.y;
    g.fillRect(Math.floor(sx), Math.floor(sy), 18, 16);
  }

  // editor overlay
  if(editMode && showGrid) drawGrid();
}
function drawHills(color, parallax, height){
  const cw=C.clientWidth, ch=C.clientHeight;
  g.save(); g.translate(-cam.x*parallax,0); g.fillStyle=color;
  for(let i=-1;i<10;i++){
    const x=i*240;
    g.beginPath();
    g.moveTo(x, ch);
    g.quadraticCurveTo(x+120, ch-height-40, x+240, ch);
    g.closePath(); g.fill();
  }
  g.restore();
}
function drawCoin(x,y){
  g.fillStyle='gold'; g.beginPath(); g.arc(x,y,7,0,Math.PI*2); g.fill();
}
function drawGrid(){
  const cw=C.clientWidth, ch=C.clientHeight;
  g.strokeStyle='rgba(255,255,255,.12)'; g.lineWidth=1;
  const startTx=Math.floor(cam.x/TILE), endTx=Math.ceil((cam.x+cw)/TILE);
  const startTy=0, endTy=LEVEL_H;
  for(let tx=startTx; tx<endTx; tx++){
    const x=tx*TILE - cam.x; g.beginPath(); g.moveTo(x,0); g.lineTo(x,ch); g.stroke();
  }
  for(let ty=startTy; ty<endTy; ty++){
    const y=ty*TILE - cam.y; g.beginPath(); g.moveTo(0,y); g.lineTo(cw,y); g.stroke();
  }
}

/* ===== Loop ===== */
let last=performance.now();
function loop(now){
  const dt=Math.min(50, now-last)/1000; last=now;
  update(dt);
  draw(now/1000);
  requestAnimationFrame(loop);
}
updateHUD();
requestAnimationFrame(loop);

/* ===== Editor ===== */
let editMode=false, currentTile=1, showGrid=true;
const editHelp=document.getElementById('editHelp');
addEventListener('keydown', e=>{
  if(e.key==='e' || e.key==='E'){ editMode=!editMode; editHelp.style.display=editMode?'block':'none'; e.preventDefault(); }
  if(!editMode) return;
  if('012345679'.includes(e.key)) currentTile=parseInt(e.key,10);
  if(e.key==='g' || e.key==='G') showGrid=!showGrid;
  if(e.key==='s' || e.key==='S'){
    console.log(JSON.stringify(Level)); alert('Level JSON logged to console.');
  }
});
C.addEventListener('contextmenu', e=>{ if(editMode) e.preventDefault(); });
C.addEventListener('mousedown', e=>{
  if(!editMode) return;
  const rect=C.getBoundingClientRect();
  const mx = (e.clientX - rect.left) + cam.x;
  const my = (e.clientY - rect.top)  + cam.y;
  const tx = Math.floor(mx/TILE), ty=Math.floor(my/TILE);
  if(ty>=0&&ty<LEVEL_H&&tx>=0&&tx<LEVEL_W){
    if(e.button===2) Level[ty][tx]=0;
    else Level[ty][tx]=currentTile;
  }
});

/* ===== Utils ===== */
function AABB(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }
</script>
</body>
</html>

