<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no"/>
<title>Ninja Worlds — Crimson Base</title>
<style>
  html,body{margin:0;height:100%;background:#1a0f0f;color:#fff;font:14px/1.2 system-ui,-apple-system,Segoe UI,Inter}
  #game{display:block;width:100vw;height:100vh;touch-action:none;background:#1a0f0f}
  /* HUD */
  #hud{position:fixed;left:12px;top:10px;display:flex;gap:10px;z-index:5}
  .badge{background:rgba(0,0,0,.55);padding:6px 10px;border-radius:10px;font-weight:800}
  /* Title overlay */
  #title{position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.42);backdrop-filter:blur(8px);z-index:10}
  .panel{background:rgba(30,18,18,.92);border:1px solid rgba(255,255,255,.15);padding:18px 22px;border-radius:14px;min-width:280px;text-align:center}
  .panel h1{margin:.25em 0 10px;font:800 22px/1.2 system-ui}
  .btn{border:0;border-radius:10px;padding:10px 16px;font-weight:800;background:#fff;color:#000;cursor:pointer}
  .hide{display:none}
</style>
</head>
<body>
<canvas id="game"></canvas>

<!-- HUD -->
<div id="hud" class="hide">
  <div id="hp" class="badge">HP: ❤❤❤</div>
  <div id="coins" class="badge">Coins: 0</div>
</div>

<!-- Title / Play -->
<div id="title">
  <div class="panel">
    <h1>Ninja Worlds — Crimson Base</h1>
    <p style="opacity:.9;margin:0 0 12px">Move: A/D or Arrows · Jump: Space · Pause: P/Esc</p>
    <button id="playBtn" class="btn">Play</button>
  </div>
</div>

<script>
/* ===== Canvas setup (CSS pixels) ===== */
const C = document.getElementById('game'), g = C.getContext('2d');
function resize(){
  const dpr = devicePixelRatio || 1;
  C.width  = Math.round(innerWidth  * dpr);
  C.height = Math.round(innerHeight * dpr);
  C.style.width  = innerWidth +'px';
  C.style.height = innerHeight+'px';
  g.setTransform(dpr,0,0,dpr,0,0);
}
resize(); addEventListener('resize', resize);

/* ===== Small helpers ===== */
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const AABB=(a,b)=>a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y;
function beep(f=660,d=.05){
  try{
    const AC = window.AudioContext||window.webkitAudioContext; if(!AC) return;
    if(!window._ac) window._ac = new AC();
    const ac=window._ac, o=ac.createOscillator(), v=ac.createGain();
    o.type='square'; o.frequency.value=f; v.gain.value=.04; o.connect(v); v.connect(ac.destination);
    o.start(); o.stop(ac.currentTime+d);
  }catch(_){}
}

/* ===== World / Level ===== */
const TILE=32;
const Level = { w:160, h:20, map:[] }; // simple 2D array level
function makeLevel(){
  // ground band + a few gaps + platforms + coins
  const W=Level.w, H=Level.h;
  Level.map.length=0;
  for(let y=0;y<H;y++){
    const row=new Array(W).fill(0);
    if(y>=H-3) row.fill(1); // ground band (solid id=1)
    Level.map.push(row);
  }
  // carve ground gaps (little pits)
  for(const x of [18,19,20, 54,55, 92,93]) Level.map[H-3][x]=0;

  // some bricks (id=2) as platforms
  function plat(tx,ty,len){ for(let i=0;i<len;i++) if(Level.map[ty]) Level.map[ty][tx+i]=2; }
  plat(10, H-6, 6);
  plat(28, H-8, 6);
  plat(46, H-10,6);
  plat(64, H-7, 6);
  plat(82, H-9, 6);
  plat(104,H-11,6);

  // coins (id=3)
  function coin(tx,ty){ if(Level.map[ty]) Level.map[ty][tx]=3; }
  coin(12,H-7); coin(30,H-9); coin(48,H-11); coin(66,H-8); coin(84,H-10); coin(106,H-12);

  // spikes (id=4)
  Level.map[H-4][60]=4; Level.map[H-4][61]=4; Level.map[H-4][62]=4;

  // flag (id=5) = win
  Level.map[H-4][W-6]=5;
}
makeLevel();

const isSolid  = id => id===1 || id===2;
const isDeadly = id => id===4;

/* robust tile lookup (CSS px) */
function tileAt(px,py){
  const tx=Math.floor(px/TILE), ty=Math.floor(py/TILE);
  if(ty<0||ty>=Level.h||tx<0||tx>=Level.w) return 0;
  return Level.map[ty][tx] | 0;
}

/* ===== Entities ===== */
const player = {
  x:3*TILE, y:(Level.h-4)*TILE-28, w:22, h:28,
  vx:0, vy:0, face:1,
  on:false, jumps:0,
  hp:3, coins:0
};
const cam = {x:0,y:0};

const enemies = []; // simple walkers
function addWalker(tx,ty,dir=1){ enemies.push({x:tx*TILE+6,y:ty*TILE-26,w:20,h:26,vx:60*dir,vy:0,alive:true}); }
for(let i=14;i<Level.w-10;i+=16) addWalker(i, Level.h-3);

/* ===== Physics: Mario-like tuning ===== */
const PHY = {
  RUN_MAX: 360,
  ACC_G:   900,
  DEC_G:   1400,
  ACC_A:   650,
  GRAV_UP:   1100,
  GRAV_DOWN: 1800,
  TERM_V:   1600,
  JUMP_V:    760,
  CUT_V:     280,
  COYOTE:   0.08,
  JBUF:     0.12
};
let coyTime=0, jumpBuf=0, prevJump=false;

/* ===== Input ===== */
const keys=Object.create(null);
addEventListener('keydown', e=>{
  const k=e.key.toLowerCase();
  if([' ','arrowleft','arrowright','arrowup','arrowdown'].includes(e.key)) e.preventDefault();
  keys[k]=true;
  if(k==='p' || e.key==='Escape') paused=!paused;
});
addEventListener('keyup',   e=>{ keys[e.key.toLowerCase()]=false; });
addEventListener('blur',    ()=>{ for(const k in keys) keys[k]=false; });

/* ===== Collisions (separate axis) ===== */
function resolveX(ent, dx){
  if(dx===0) return;
  ent.x += dx;
  const L = Math.floor(ent.x/TILE);
  const R = Math.floor((ent.x+ent.w-1)/TILE);
  const T = Math.floor(ent.y/TILE);
  const B = Math.floor((ent.y+ent.h-1)/TILE);
  for(let ty=T; ty<=B; ty++){
    for(let tx=L; tx<=R; tx++){
      const id = tileAt(tx*TILE+1, ty*TILE+1);
      if(!isSolid(id)) continue;
      if(dx>0) ent.x = tx*TILE - ent.w; else ent.x = (tx+1)*TILE;
      ent.vx = 0; return;
    }
  }
  // hazards touch while sweeping X
  if(ent===player){
    for(let ty=T; ty<=B; ty++) for(let tx=L; tx<=R; tx++){
      if(isDeadly(tileAt(tx*TILE+1, ty*TILE+1))) damage(1);
    }
  }
}
function resolveY(ent, dy){
  if(dy===0) return;
  ent.y += dy;
  const L = Math.floor(ent.x/TILE);
  const R = Math.floor((ent.x+ent.w-1)/TILE);
  const T = Math.floor(ent.y/TILE);
  const B = Math.floor((ent.y+ent.h-1)/TILE);
  let landed=false;
  for(let ty=T; ty<=B; ty++){
    for(let tx=L; tx<=R; tx++){
      const id = tileAt(tx*TILE+1, ty*TILE+1);
      if(!isSolid(id)) continue;
      if(dy>0){ ent.y = ty*TILE - ent.h; ent.vy=0; landed=true; }
      else    { ent.y = (ty+1)*TILE; if(ent.vy<0) ent.vy=0; }
      ty=B+1; break; // stop after resolving a tile on Y
    }
  }
  if(ent===player){
    player.on = landed;
    // coins / spikes / flag
    for(let ty=T; ty<=B; ty++){
      for(let tx=L; tx<=R; tx++){
        const id = tileAt(tx*TILE+1, ty*TILE+1);
        if(id===3){ Level.map[ty][tx]=0; player.coins++; beep(880,.06); updateHUD(); }
        if(id===4) damage(1);
        if(id===5) youWin();
      }
    }
  }
}

/* ===== HUD ===== */
const HUD = { hp:document.getElementById('hp'), coins:document.getElementById('coins') };
function updateHUD(){
  HUD.hp.textContent = 'HP: ' + '❤'.repeat(player.hp) + '♡'.repeat(Math.max(0,3-player.hp));
  HUD.coins.textContent = 'Coins: ' + player.coins;
}
function damage(n){
  player.hp = Math.max(0, player.hp - n);
  updateHUD(); if(player.hp===0) respawn();
}
function respawn(){
  player.x=3*TILE; player.y=(Level.h-4)*TILE - player.h;
  player.vx=player.vy=0; player.on=false; coyTime=0; jumpBuf=0;
}

/* ===== Game loop pieces ===== */
let running=false, paused=false;

function update(dt){
  if(!running || paused) return;

  // === Player movement (Mario-ish) ===
  const left  = !!(keys.a || keys.arrowleft);
  const right = !!(keys.d || keys.arrowright);
  const jump  = !!(keys[' '] || keys.space);

  if(right) player.face=1; else if(left) player.face=-1;

  coyTime = player.on ? PHY.COYOTE : Math.max(0, coyTime - dt);
  jumpBuf = jump ? PHY.JBUF : Math.max(0, jumpBuf - dt);
  if (jump) jumpBuf = PHY.JBUF; // buffer refresh while held

  const want = (right?1:0) - (left?1:0);
  if(want!==0){
    const acc = player.on ? PHY.ACC_G : PHY.ACC_A;
    player.vx += want * acc * dt;
    player.vx = clamp(player.vx, -PHY.RUN_MAX, PHY.RUN_MAX);
  }else if(player.on){
    const m = Math.min(Math.abs(player.vx), PHY.DEC_G*dt);
    player.vx -= Math.sign(player.vx)*m; if(Math.abs(player.vx)<0.01) player.vx=0;
  }

  const canGroundJump = (coyTime>0);
  if(jumpBuf>0 && canGroundJump){
    player.vy = -PHY.JUMP_V; player.on=false; coyTime=0; jumpBuf=0; player.jumps=1; beep(600,.05);
  }

  // short hop
  if(!jump && prevJump && player.vy < -PHY.CUT_V) player.vy = -PHY.CUT_V;
  prevJump = jump;

  // gravity
  const g = (player.vy<0) ? PHY.GRAV_UP : PHY.GRAV_DOWN;
  player.vy = Math.min(PHY.TERM_V, player.vy + g*dt);

  // integrate vs tiles
  resolveX(player, player.vx * dt);
  const prevY = player.y;
  resolveY(player, player.vy * dt);
  if(player.on && player.y===prevY) player.jumps=0;

  // enemies
  for(const e of enemies){
    if(!e.alive) continue;
    // simple AI: flip at edges or walls
    const aheadX = e.x + (e.vx>0 ? e.w+1 : -1);
    const footY  = e.y + e.h + 2;
    const wall   = tileAt(aheadX, e.y + e.h/2);
    const ground = tileAt(e.x + e.w/2 + (e.vx>0?14:-14), footY);
    if(isSolid(wall) || !isSolid(ground)) e.vx *= -1;

    e.vy = Math.min(PHY.TERM_V, e.vy + PHY.GRAV_DOWN*dt);
    resolveX(e, e.vx*dt);
    resolveY(e, e.vy*dt);

    // stomp / hurt
    if(AABB(player,e)){
      const prevBottom = player.y + player.h - player.vy*dt;
      if(player.vy>0 && prevBottom <= e.y+6){ e.alive=false; player.vy=-PHY.JUMP_V*0.6; beep(720,.06); }
      else damage(1);
    }
  }

  // death pit
  if(player.y > Level.h*TILE + 200) damage(3);

  // camera
  const cw=C.clientWidth;
  const tx = clamp(player.x - cw*0.4, 0, Level.w*TILE - cw);
  cam.x += (tx - cam.x) * 0.15; cam.y=0;
}

function draw(t){
  const cw=C.clientWidth, ch=C.clientHeight;

  // background gradient (crimson dusk)
  const wobble=Math.sin(t*.3)*16;
  const grad=g.createLinearGradient(0,ch+wobble,0,0);
  grad.addColorStop(0.00,'#8A2232');
  grad.addColorStop(0.33,'#9B2D3B');
  grad.addColorStop(0.66,'#A33C44');
  grad.addColorStop(1.00,'#FFB37E');
  g.fillStyle=grad; g.fillRect(0,0,cw,ch);

  // tiles in view
  const startTx = Math.floor(cam.x/TILE);
  const endTx   = Math.ceil((cam.x+cw)/TILE);
  for(let ty=0; ty<Level.h; ty++){
    for(let tx=startTx; tx<Math.min(endTx,Level.w); tx++){
      const id=Level.map[ty][tx]; if(!id) continue;
      const x=tx*TILE - cam.x, y=ty*TILE - cam.y;
      if(id===1){ g.fillStyle='#2e2a3a'; g.fillRect(x,y,TILE,TILE); }           // ground
      if(id===2){ g.fillStyle='#57455d'; g.fillRect(x+2,y+2,TILE-4,TILE-4); }   // brick
      if(id===3){ g.fillStyle='gold'; g.beginPath(); g.arc(x+16,y+16,7,0,Math.PI*2); g.fill(); } // coin
      if(id===4){ g.fillStyle='#b43636'; g.beginPath(); g.moveTo(x,y+TILE); g.lineTo(x+TILE/2,y+4); g.lineTo(x+TILE,y+TILE); g.closePath(); g.fill(); } // spikes
      if(id===5){ g.fillStyle='#c0ffb3'; g.fillRect(x+20,y-100,6,100); g.fillStyle='#45fd6c'; g.beginPath(); g.moveTo(x+26,y-96); g.lineTo(x+80,y-76); g.lineTo(x+26,y-56); g.closePath(); g.fill(); } // flag
    }
  }

  // enemies
  g.fillStyle='#ff6e6e';
  for(const e of enemies){ if(!e.alive) continue; g.fillRect(Math.floor(e.x-cam.x), Math.floor(e.y-cam.y), e.w, e.h); }

  // player (simple)
  g.fillStyle='#ffecef';
  g.fillRect(Math.floor(player.x-cam.x), Math.floor(player.y-cam.y), player.w, player.h);
}

/* ===== Loop ===== */
let last=performance.now();
function loop(now){
  const dt=Math.min(50, now-last)/1000; last=now;
  if(running) update(dt);
  draw(now/1000);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ===== Flow (Title -> Play) ===== */
const title = document.getElementById('title');
const hud   = document.getElementById('hud');
const playBtn = document.getElementById('playBtn');

function startGame(){
  // mobile audio unlock
  try{
    const AC=window.AudioContext||window.webkitAudioContext;
    if(AC){ if(!window._ac) window._ac=new AC(); if(window._ac.state==='suspended') window._ac.resume(); }
  }catch(_){}
  title.classList.add('hide');
  hud.classList.remove('hide');
  updateHUD();
  running=true;
}
// click/tap anywhere or button
playBtn.addEventListener('pointerdown', startGame, {once:true});
title.addEventListener('pointerdown',  (e)=>{ if(e.target===title) startGame(); }, {once:true});
window.addEventListener('keydown',     (e)=>{ if(!running) startGame(); }, {once:true});
</script>
</body>
</html>