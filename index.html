<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Ninja Worlds ‚Äî Crimson Dusk</title>
<style>
  :root{--ink:#0b0d12;--ui:rgba(255,255,255,.92)}
  html,body{margin:0;height:100%;background:#1a0f0f;color:#fff;font:14px/1.25 system-ui,-apple-system,Segoe UI,Inter}
  canvas{display:block;margin:0 auto;background:#1a0f0f;touch-action:none}
  .overlay{position:fixed;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.5);backdrop-filter:blur(8px);z-index:10}
  .panel{background:rgba(22,18,26,.92);border:1px solid rgba(255,255,255,.15);padding:18px 20px;border-radius:14px;min-width:280px;max-width:92vw}
  .panel h2{margin:.2em 0 10px;font:800 18px/1.2 system-ui}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .btn{border:0;border-radius:10px;padding:10px 14px;font-weight:800;background:#fff;color:#000;cursor:pointer}
  #hud{position:fixed;left:12px;top:10px;display:flex;gap:10px;z-index:5;flex-wrap:wrap}
  .badge{background:rgba(0,0,0,.55);padding:6px 10px;border-radius:10px;font-weight:800}
  #tips{position:fixed;right:12px;top:10px;opacity:.9;background:rgba(0,0,0,.45);padding:6px 10px;border-radius:10px;z-index:5}
  .hide{display:none}
  /* Touch */
  .touch{position:fixed;left:12px;right:12px;bottom:16px;display:none;justify-content:space-between;align-items:flex-end;gap:12px;z-index:9}
  .pad{display:flex;gap:12px}
  .tbtn{width:68px;height:68px;border-radius:999px;border:0;background:rgba(255,255,255,.12);backdrop-filter:blur(8px);color:#fff;font:800 14px system-ui;display:grid;place-items:center;box-shadow:inset 0 0 0 2px rgba(255,255,255,.15)}
  .tbtn:active{transform:scale(.97)}
  .lg{width:84px;height:84px}
  @media (max-width: 820px){ .touch{display:flex} }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud" class="hide">
  <div id="hp" class="badge">HP: ‚ù§‚ù§‚ù§</div>
  <div id="coins" class="badge">Coins: 0</div>
  <div id="spec" class="badge">Special: ‚Äî</div>
</div>
<div id="tips" class="hide">Move: WASD/Arrows ¬∑ Jump: Space ¬∑ Attack: J ¬∑ Dash: Shift ¬∑ Special: K ¬∑ Pause: P/Esc</div>

<!-- Touch controls -->
<div class="touch" id="touch">
  <div class="pad">
    <button id="tLeft"  class="tbtn lg">‚óÄÔ∏é</button>
    <button id="tRight" class="tbtn lg">‚ñ∂Ô∏é</button>
  </div>
  <div class="pad">
    <button id="tJump"  class="tbtn lg">‚§¥Ô∏é</button>
    <button id="tAtk"   class="tbtn">Atk</button>
    <button id="tDash"  class="tbtn">Dash</button>
    <button id="tSpec"  class="tbtn">Spec</button>
  </div>
</div>

<!-- Title -->
<div id="title" class="overlay">
  <div class="panel">
    <h2>Ninja Worlds ‚Äî Crimson Dusk</h2>
    <p style="opacity:.85;margin:.2em 0 10px">Tap/click Play to start. iPhone ready.</p>
    <div class="row"><button id="play" class="btn">Play</button></div>
  </div>
</div>

<!-- Pause -->
<div id="pause" class="overlay hide">
  <div class="panel">
    <h2>Paused</h2>
    <div class="row">
      <button id="resume" class="btn">Resume</button>
      <button id="restart" class="btn">Restart</button>
      <button id="menu" class="btn">Menu</button>
    </div>
  </div>
</div>

<!-- Win -->
<div id="win" class="overlay hide">
  <div class="panel">
    <h2>You Win! üéâ</h2>
    <div class="row"><button id="again" class="btn">Play Again</button></div>
  </div>
</div>

<script>
// ===== Canvas (CSS px physics) =====
const C = document.getElementById('game'), g = C.getContext('2d');
function resize(){
  const dpr = devicePixelRatio||1;
  C.width = Math.round(innerWidth*dpr); C.height = Math.round(innerHeight*dpr);
  C.style.width = innerWidth+'px'; C.style.height = innerHeight+'px';
  g.setTransform(dpr,0,0,dpr,0,0);
}
resize(); addEventListener('resize', resize);

// ===== Tiny audio (works on iPhone after gesture) =====
let ac=null, muted=false; function ensureAC(){ if(!ac){ const AC=window.AudioContext||window.webkitAudioContext; if(AC) ac=new AC(); } return ac; }
function beep(f=660,d=.06){ if(muted) return; try{ const ac=ensureAC(); if(!ac) return; const o=ac.createOscillator(), v=ac.createGain(); o.type='square'; o.frequency.value=f; v.gain.value=.05; o.connect(v); v.connect(ac.destination); o.start(); o.stop(ac.currentTime+d); }catch(_){}}

// ===== World / tiles =====
const TILE=32; const LEVEL_W=168, LEVEL_H=18; // wide, short like SMB 1-1
// build ground + simple platforms and a flag
const Level = Array.from({length:LEVEL_H}, (_,y)=>{
  const row = new Array(LEVEL_W).fill(0);
  if(y>=LEVEL_H-3) row.fill(1); // ground band
  return row;
});
function setT(tx,ty,id){ if(Level[ty] && Level[ty][tx]!=null) Level[ty][tx]=id; }
function stamp(tx,ty,w,id){ for(let i=0;i<w;i++) setT(tx+i,ty,id); }
// holes in ground
for(let x=22;x<=24;x++) Level[LEVEL_H-3][x]=0;
for(let x=58;x<=60;x++) Level[LEVEL_H-3][x]=0;
// bricks/coins
stamp(14,LEVEL_H-6,6,2); setT(16,LEVEL_H-7,3); setT(18,LEVEL_H-7,3);
stamp(34,LEVEL_H-8,5,2); setT(36,LEVEL_H-9,3);
stamp(52,LEVEL_H-7,6,2); setT(54,LEVEL_H-8,3);
// spring & spikes & flag
setT(40,LEVEL_H-4,7); setT(46,LEVEL_H-4,4); setT(LEVEL_W-6,LEVEL_H-4,5);

// ids: 0 empty, 1 ground, 2 brick, 3 coin, 4 spikes, 5 flag, 7 spring
const solid=id=>id===1||id===2; const deadly=id=>id===4;
function tileAt(px,py){ const tx=Math.floor(px/TILE), ty=Math.floor(py/TILE); if(ty<0||ty>=LEVEL_H||tx<0||tx>=LEVEL_W) return 0; return Level[ty][tx]; }

// ===== Player (Mario-like tuning) =====
const P = {x:3*TILE, y:(LEVEL_H-4)*TILE-28, w:22, h:28, vx:0, vy:0, face:1, on:false, wasOn:false, jumps:0, maxJ:1, dashCd:0, attackT:0, hp:3, iFrames:0, coins:0};
const GRAV=2100, RUN=300, AIR_ACCEL=2200, DECEL=6000, JUMP_V=610, MAX_FALL=1400, DASH=520;
const COYOTE_MAX=0.08, JUMP_BUF=0.12; let coyote=0, jbuf=0;

// ===== Input (desktop + mobile) =====
const keys=Object.create(null);
addEventListener('keydown',e=>{ const k=e.key.toLowerCase(); if([' ','arrowleft','arrowright','arrowup','arrowdown'].includes(e.key)) e.preventDefault(); keys[k]=true; if(k==='p' || e.key==='Escape') togglePause(true); });
addEventListener('keyup',e=>{ keys[e.key.toLowerCase()]=false; });
addEventListener('blur',()=>{ for(const k in keys) keys[k]=false; P.vx=0; });

// touch controls
const tc=document.getElementById('touch');
function bindHold(id,down,up){ const el=document.getElementById(id); const press=e=>{e.preventDefault();down();}; const lift=e=>{e.preventDefault();up();}; ['pointerdown','touchstart','mousedown'].forEach(t=>el.addEventListener(t,press)); ['pointerup','pointercancel','touchend','mouseleave','mouseup'].forEach(t=>el.addEventListener(t,lift)); }
const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints>0; if(isTouch) tc.style.display='flex';
bindHold('tLeft', ()=>{keys['a']=keys['arrowleft']=true;}, ()=>{keys['a']=keys['arrowleft']=false;});
bindHold('tRight',()=>{keys['d']=keys['arrowright']=true;},()=>{keys['d']=keys['arrowright']=false;});
bindHold('tJump', ()=>{keys[' ']=keys['space']=true;}, ()=>{keys[' ']=keys['space']=false;});
bindHold('tAtk',  ()=>{keys['j']=true;}, ()=>{keys['j']=false;});
bindHold('tDash', ()=>{keys['shift']=true;}, ()=>{keys['shift']=false;});
bindHold('tSpec', ()=>{keys['k']=true;}, ()=>{keys['k']=false;});

// ===== HUD =====
const HUD={hp:qs('#hp'), coins:qs('#coins'), spec:qs('#spec')}; function qs(s){return document.querySelector(s);} function setHUD(){ HUD.hp.textContent='HP: '+ '‚ù§'.repeat(P.hp)+'‚ô°'.repeat(Math.max(0,3-P.hp)); HUD.coins.textContent='Coins: '+P.coins; }

// ===== Collisions (swept on grid, CSS px) =====
function resolveX(ent, dx){ ent.x += dx; const L=Math.floor(ent.x/TILE), R=Math.floor((ent.x+ent.w-1)/TILE), T=Math.floor(ent.y/TILE), B=Math.floor((ent.y+ent.h-1)/TILE); for(let ty=T; ty<=B; ty++){ for(let tx=L; tx<=R; tx++){ const id=tileAt(tx*TILE+1, ty*TILE+1); if(solid(id)){ if(dx>0) ent.x = tx*TILE - ent.w; else ent.x = (tx+1)*TILE; ent.vx=0; } if(ent===P && deadly(id)) damage(1); } } }
function resolveY(ent, dy){ ent.y += dy; const L=Math.floor(ent.x/TILE), R=Math.floor((ent.x+ent.w-1)/TILE), T=Math.floor(ent.y/TILE), B=Math.floor((ent.y+ent.h-1)/TILE); let on=false; for(let ty=T; ty<=B; ty++){ for(let tx=L; tx<=R; tx++){ const id=tileAt(tx*TILE+1, ty*TILE+1); if(solid(id)){ if(dy>0){ ent.y = ty*TILE - ent.h; ent.vy=0; on=true; } else { ent.y = (tx, (ty+1)*TILE); if(ent.vy<0) ent.vy=0; } } if(ent===P){ if(id===3){ Level[ty][tx]=0; P.coins++; beep(880,.05); setHUD(); } if(id===7 && dy>0){ P.vy=-JUMP_V*1.2; beep(760,.07);} if(id===5){ win(); } if(deadly(id)) damage(1); } } } ent.on = on; }

// ===== Game state =====
let running=false, cam={x:0,y:0};

function damage(n){ if(P.iFrames>0) return; P.hp=Math.max(0,P.hp-n); P.iFrames=0.9; P.vy=-320; beep(220,.06); setHUD(); if(P.hp===0) respawn(); }
function respawn(){ P.x=3*TILE; P.y=(LEVEL_H-4)*TILE-28; P.vx=P.vy=0; P.hp=3; P.iFrames=0; setHUD(); }
function win(){ running=false; qs('#win').classList.remove('hide'); }

// ===== Update (Mario-feel) =====
function update(dt){
  if(!running) return;
  const left=keys.a||keys.arrowleft, right=keys.d||keys.arrowright, jump=keys[' ']|keys.space, dash=keys.shift, atk=keys.j;

  P.wasOn=P.on; P.on=false;
  // timers
  coyote = Math.min(COYOTE_MAX, P.wasOn? COYOTE_MAX : Math.max(0, coyote - dt));
  jbuf = Math.max(0, jbuf - dt);
  if(jump){ if(jbuf<=0) jbuf = JUMP_BUF; }

  // horizontal
  const ax=(right?1:0)-(left?1:0);
  P.vx += ax * (P.wasOn? RUN*12 : AIR_ACCEL) * dt;
  P.vx = Math.max(-RUN, Math.min(RUN, P.vx));
  if(ax===0 && P.wasOn){ const dec = Math.sign(P.vx)*Math.min(Math.abs(P.vx), DECEL*dt); P.vx -= dec; if(Math.abs(P.vx)<0.12) P.vx=0; }
  if(right) P.face=1; if(left) P.face=-1;

  // jump (with coyote + cut)
  if(jbuf>0 && (coyote>0 || (!P.wasOn && P.jumps<P.maxJ))){ P.vy=-JUMP_V; P.jumps = P.wasOn? 1 : P.jumps+1; jbuf=0; coyote=0; keys[' ']=keys['space']=false; beep(640,.06); }
  if(!(keys[' ']||keys['space']) && P.vy<-160) P.vy=-160; // jump cut

  // dash burst
  if(dash && P.dashCd<=0){ P.vx += DASH * P.face; P.dashCd=.35; beep(440,.05); }
  P.dashCd=Math.max(0, P.dashCd - dt);

  // gravity + integrate
  P.vy += GRAV*dt; if(P.vy>MAX_FALL) P.vy=MAX_FALL;
  resolveX(P, P.vx*dt);
  resolveY(P, P.vy*dt);
  if(P.on){ P.jumps=0; coyote=COYOTE_MAX; }

  // death pit
  if(P.y > LEVEL_H*TILE + 200) damage(3);

  // i-frames
  P.iFrames=Math.max(0, P.iFrames - dt);

  // camera
  const cw=C.clientWidth; const worldW=LEVEL_W*TILE; const tx = Math.max(0, Math.min(worldW-cw, P.x - cw*0.4)); cam.x += (tx - cam.x) * 0.14;
}

// ===== Draw =====
function draw(t){
  const cw=C.clientWidth, ch=C.clientHeight;
  // sky gradient (crimson dusk)
  const grad=g.createLinearGradient(0,ch,0,0); grad.addColorStop(0,'#8A2232'); grad.addColorStop(.33,'#9B2D3B'); grad.addColorStop(.66,'#A33C44'); grad.addColorStop(1,'#FFB37E'); g.fillStyle=grad; g.fillRect(0,0,cw,ch);
  // parallax hills
  drawHills('#33111a', .10, 110); drawHills('#4a1a24', .18, 80); drawHills('#642233', .28, 48);
  // tiles in view
  const startTx=Math.floor(cam.x/TILE), endTx=Math.ceil((cam.x+cw)/TILE);
  for(let ty=0; ty<LEVEL_H; ty++){
    for(let tx=startTx; tx<Math.min(endTx, LEVEL_W); tx++){
      const id = Level[ty][tx]; if(id===0) continue; const x=tx*TILE-cam.x, y=ty*TILE;
      if(id===1){ g.fillStyle='#2e2a3a'; g.fillRect(x,y,TILE,TILE); }
      if(id===2){ g.fillStyle='#57455d'; g.fillRect(x+2,y+2,TILE-4,TILE-4); }
      if(id===3){ g.fillStyle='gold'; g.beginPath(); g.arc(x+16,y+16,7,0,Math.PI*2); g.fill(); }
      if(id===4){ g.fillStyle='#b43636'; g.beginPath(); g.moveTo(x,y+TILE); g.lineTo(x+TILE/2,y+4); g.lineTo(x+TILE,y+TILE); g.closePath(); g.fill(); }
      if(id===5){ g.fillStyle='#c0ffb3'; g.fillRect(x+20,y-100,6,100); g.fillStyle='#45fd6c'; g.beginPath(); g.moveTo(x+26,y-96); g.lineTo(x+80,y-76); g.lineTo(x+26,y-56); g.closePath(); g.fill(); }
      if(id===7){ g.fillStyle='#9b6bff'; g.fillRect(x+4,y+10,TILE-8,8); }
    }
  }
  // player (blink during i-frames)
  if(!(P.iFrames>0 && ((t*10|0)%2===0))){ g.fillStyle='#ffecef'; g.fillRect(Math.floor(P.x-cam.x), Math.floor(P.y), P.w, P.h); }
}
function drawHills(color, parallax, h){ const cw=C.clientWidth, ch=C.clientHeight; g.save(); g.translate(-cam.x*parallax,0); g.fillStyle=color; for(let i=-1;i<10;i++){ const x=i*240; g.beginPath(); g.moveTo(x, ch); g.quadraticCurveTo(x+120, ch-h-40, x+240, ch); g.closePath(); g.fill(); } g.restore(); }

// ===== Loop =====
let last=performance.now(); function loop(now){ const dt=Math.min(50, now-last)/1000; last=now; if(running) update(dt); draw(now/1000); requestAnimationFrame(loop);} requestAnimationFrame(loop);

// ===== UI / Flow =====
const UI={title:qs('#title'), pause:qs('#pause'), win:qs('#win'), tips:qs('#tips'), hud:qs('#hud')};
qs('#play').addEventListener('click', startGame, {once:true});
function startGame(){ unlockAudio(); UI.title.classList.add('hide'); UI.hud.classList.remove('hide'); UI.tips.classList.remove('hide'); running=true; C.focus(); }
function unlockAudio(){ try{ const ac=ensureAC(); if(ac && ac.state==='suspended'){ ac.resume(); } }catch(_){} }
function togglePause(show){ if(show){ running=false; UI.pause.classList.remove('hide'); } else { UI.pause.classList.add('hide'); running=true; C.focus(); } }
qs('#resume').onclick=()=>togglePause(false); qs('#restart').onclick=()=>{ togglePause(false); respawn(); }; qs('#menu').onclick=()=>{ running=false; UI.title.classList.remove('hide'); };
qs('#again').onclick=()=>{ UI.win.classList.add('hide'); respawn(); running=true; };

// keyboard to start as well (mobile requires tap once)
addEventListener('keydown', e=>{ if(!running && !UI.title.classList.contains('hide')) startGame(); });

// initial HUD
setHUD();
</script>
</body>
</html>
